(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{361:function(n,t,a){"use strict";a.r(t);var e=a(33),r=Object(e.a)({},(function(){var n=this,t=n.$createElement,a=n._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h1",{attrs:{id:"dart-入门"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dart-入门"}},[n._v("#")]),n._v(" Dart 入门")]),n._v(" "),a("h2",{attrs:{id:"安装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[n._v("#")]),n._v(" 安装")]),n._v(" "),a("p",[n._v("不同的开发平台需要下载不同的SDK")]),n._v(" "),a("p",[a("a",{attrs:{href:"https://www.dartcn.com/",target:"_blank",rel:"noopener noreferrer"}},[n._v("Dart编程语言"),a("OutboundLink")],1)]),n._v(" "),a("p",[n._v("windows 平台的 下载后,解压, 然后放到一个目录(名称不要有空格), 把 bin目录,添加到系统环境变量里.")]),n._v(" "),a("p",[n._v("VScode 安装 Dart, Flutter 插件, 编程过程体验更佳.")]),n._v(" "),a("h2",{attrs:{id:"dart-hello-world"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dart-hello-world"}},[n._v("#")]),n._v(" Dart Hello World")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("/**\n * 这里是文档注释\n */\nvoid main() {\n\n  // 单行注释\n  print(\"Hello world\");   // 这里后面的都是注释\n\n  print('This is my first application');\n\n  print(4);\n\n  print(1/4);\n\n  print(false);\n}\n}\n")])])]),a("ul",[a("li",[n._v("main 是入口函数, 主函数, 即这个文件(模块)的执行从这个函数开始")]),n._v(" "),a("li",[n._v("main 是函数名,  函数名前的 占位符 是返回值的类型, void 表示没有返回值")]),n._v(" "),a("li",[n._v("print() 函数, 从终端输出字符")])]),n._v(" "),a("h2",{attrs:{id:"注释"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注释"}},[n._v("#")]),n._v(" 注释")]),n._v(" "),a("ul",[a("li",[n._v("// 是单行注释,  它之后的内容都是注释的内容")]),n._v(" "),a("li",[n._v("/* */  是多行注释  它之间的内容都是注释的内容")])]),n._v(" "),a("h2",{attrs:{id:"变量与数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#变量与数据类型"}},[n._v("#")]),n._v(" 变量与数据类型")]),n._v(" "),a("h3",{attrs:{id:"数据类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[n._v("#")]),n._v(" 数据类型")]),n._v(" "),a("ul",[a("li",[n._v("Numbers\n"),a("ul",[a("li",[n._v("int")]),n._v(" "),a("li",[n._v("double")])])]),n._v(" "),a("li",[n._v("Strings")]),n._v(" "),a("li",[n._v("Booleans")]),n._v(" "),a("li",[n._v("Lists (类似Arrays)")]),n._v(" "),a("li",[n._v("Maps")]),n._v(" "),a("li",[n._v("Runes")]),n._v(" "),a("li",[n._v("Symbols")])]),n._v(" "),a("p",[a("strong",[n._v("一切数据类型都是对象，默认值都是null,即声明时没赋值,则值为null")])]),n._v(" "),a("h3",{attrs:{id:"声明变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#声明变量"}},[n._v("#")]),n._v(" 声明变量")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('//数据类型  变量名   值\nint age = 10;\n\nvar age = 10;   //它没有声明数据类型,但它会自动推断age是int\n\nString name = "yycu"\n\nbool isAlive = true\n\nString name = "yycu";\n\nbool isAlive = true;\n\nint age = 10;\n\ndouble height = 1.67;\n')])])]),a("h3",{attrs:{id:"字面量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字面量"}},[n._v("#")]),n._v(" 字面量")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('true\n2\n"Kevin"\n4.5\n\n//以上这几种就是字面量, 他们可以赋值给变量\n\n// 几个方法 定义 字符串的字面量\nString s1 = \'Single\';\nString s2 = "Double";\nString s3 = "It\\\'s eays\';    // \\\' 是转义\nString s4 = "It\'s easy";    //可以外面用双引号\n\nString s5 = "one ...." +\n            "two ....";    //可以用 + 来拼接字符串\n\n// 解析变量\nString name = "Kevin";\n\nString message = "My name is　$name";   // $后面全被视为变量, 因此一般需要加一个 {}\nString message = "My name is　${name}";   // 才是最好的选择\nprint(message)  // My name is Kevin\n\nprint("The number of characters is String Kevin is ${name.length} ")  //{}简单的表达式还是可以解析的\n\nint a = 20;\nint b = 10;\nprint("a + b = ${ a +b}"); // a + b = 30;\n')])])]),a("h3",{attrs:{id:"常量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常量"}},[n._v("#")]),n._v(" 常量")]),n._v(" "),a("p",[n._v("永远不变的量,可以用 final const 来声明")]),n._v(" "),a("ul",[a("li",[a("p",[n._v("final")]),n._v(" "),a("ul",[a("li",[n._v('final name = "Kevin"')]),n._v(" "),a("li",[n._v("用于修饰变量，表示单赋值（single-assignment），使用final修饰的变量必须进行初始化，一旦被赋值之后，不能够再次被赋值,否则编译会报错。跟java的区别是：final不能用来修饰类和方法。")])])]),n._v(" "),a("li",[a("p",[n._v("const")]),n._v(" "),a("ul",[a("li",[n._v('const PI ＝ "3.14"')]),n._v(" "),a("li",[n._v("表示对象的状态完全可以在编译期间确定，并且完全是不可变的。")]),n._v(" "),a("li",[n._v("const变量不会在内存中重复创建，如果表达式被调用了多次，则重用之前创建好的常量。")]),n._v(" "),a("li",[n._v("const构造函数的前提是成员变量必须都是用final修饰的。const单例多例可以如下实现")])])]),n._v(" "),a("li",[a("p",[n._v("static")]),n._v(" "),a("ul",[a("li",[n._v("用于修饰成员变量，这个变量是属于类的，而不是属于对象的，除此之外没有其他别的含义了，static修饰符的使用方式和Java类似。 static变量直到运行期被使用时才会实例化。")])])])]),n._v(" "),a("h2",{attrs:{id:"流程控制语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#流程控制语句"}},[n._v("#")]),n._v(" 流程控制语句")]),n._v(" "),a("h4",{attrs:{id:"if-else"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#if-else"}},[n._v("#")]),n._v(" if else")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("if(condition) {\n  // codition条件为真,执行这里\n} else {\n  // 条件为假, 执行这里\n}\n\n// 一个条件成立, 就不再判断其它条件了, 要注音条件的先后\nif(condition1) {\n\n} else if(condition2) {\n\n} else if (condition3) {\n\n} else {\n\n}\n")])])]),a("h4",{attrs:{id:"三元表达式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三元表达式"}},[n._v("#")]),n._v(" 三元表达式")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("// condition? exp1 : exp2;     条件为真,执行exp1  假,执行 exp2\n")])])]),a("h4",{attrs:{id:"默认值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认值"}},[n._v("#")]),n._v(" ?? (默认值)")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('exp1 ?? exp2;   exp1 为真, 则 为exp1 ,  exp1 为假,则为epx2\n\nString name = "yycu";\nString nameTo = name ?? "Guest User";  // yycu\n')])])]),a("h4",{attrs:{id:"switch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#switch"}},[n._v("#")]),n._v(" switch")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('String grad = "A";\nswitch (grade) {\n  case \'A\': \n    print("A");\n    break;\n  case \'B\':\n    print("B");\n    break;\n  case \'C\':\n    print("C");\n    break;\n  default: \n    print("FAIL");\n}\n')])])]),a("ul",[a("li",[n._v("case 的值可以是 int  或 String.  其它数据类型不可以.")])]),n._v(" "),a("h2",{attrs:{id:"迭代"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#迭代"}},[n._v("#")]),n._v(" 迭代")]),n._v(" "),a("h4",{attrs:{id:"for-while-do-while"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-while-do-while"}},[n._v("#")]),n._v(" for  while   do...while")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main() {\n  // 知道具体循环几次, 用这个\n  for(var i = 0; i< 4; i++) {\n    print("Hello");\n  }\n\n  // 不知道具体循环几次 用 while 循环, 如果一定要至少循环一次用 do...while\n  int i = 0;\n  while(i<4) {\n    print("Hello ...");\n    i++;\n  }\n\n  int j = 0;\n\n  do {\n    print("Hello do...");\n    j ++;\n  } while(j<4);\n}\n\n')])])]),a("h4",{attrs:{id:"for-for-in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#for-for-in"}},[n._v("#")]),n._v(" for    for...in")]),n._v(" "),a("p",[a("strong",[n._v("找到偶数")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("  //    初始值; 条件;  增或减\n  for (int i = 0; i<= 10; i++) {\n    if( i%2 == 0) {\n      print(i);\n    }\n  }\n")])])]),a("p",[a("strong",[n._v("迭代list")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('  List planets = ["Mercury", "Venus", "Earch", "Mars"];\n  for (String i in planets) {\n    print(i);\n  }\n')])])]),a("h4",{attrs:{id:"while"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#while"}},[n._v("#")]),n._v(" while")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main(){\n  // 初始值 \n  var i = 1;\n      //条件\n  while(i<= 10) {\n    if ( i%2 == 0) {\n      print(i);\n    }\n    \n    // 增/减\n    i++;\n  }\n}\n")])])]),a("h4",{attrs:{id:"do-while"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#do-while"}},[n._v("#")]),n._v(" do...while")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main(){\n  // 初始值\n  int i = 0;\n  do {\n    if(i%2 == 0) {             //循环体一定会执行至少一次, 即使,条件不符合\n      print(i);\n    }\n    i++;   // 增/ 减\n  } while(i<=10);\n        // 条件\n}\n")])])]),a("h4",{attrs:{id:"break"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#break"}},[n._v("#")]),n._v(" break")]),n._v(" "),a("p",[n._v("break  跳出循环, 只跳出本层的循环,  可以加label 来指定跳出的循环层")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("myOuterLoop: for(int i = 1; i<= 3; i++) {\n  innerLoop:  for(int j= 1; j<= 3; j++) {\n    if(I==2 && j==2){\n      break myOuterLoop;     //指定了label 就直跳出到指定的循环层\n    }\n  }\n}\n\n")])])]),a("h4",{attrs:{id:"continue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#continue"}},[n._v("#")]),n._v(" continue")]),n._v(" "),a("p",[n._v("continue  跳过这次循环(continue之后的代码不运行), 接着下一次")]),n._v(" "),a("p",[n._v("没有 label 一般是本循环层, 也可以给循环加 label 提定,像上面 break那样")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\n  for(int i = 1; i<= 10; i++) {\n    if(i == 5) {\n      continue;   // 等于 5 时, 跳过这镒循环,即不打印 5了, 因为代码在\n    }             // continue 后面, 直接进入下次的循环\n\n    print(i);\n  }\n")])])]),a("h2",{attrs:{id:"函数-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函数-方法"}},[n._v("#")]),n._v(" 函数 / 方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("//返回值类型     函数名        参数\nint             FunctionName(int arg) {\n  // fn body\n  return xxx;      \n}\n\n")])])]),a("ul",[a("li",[n._v("函数  也是对象, 可以赋值给变量, 也可当参数传给其它函数")]),n._v(" "),a("li",[n._v("函数总是有返回值, 如果没有显式的 return 某个值, 则默认 是null")]),n._v(" "),a("li",[n._v("返回值类型, 是可以选的, 但推荐写, 不要省略")])]),n._v(" "),a("h4",{attrs:{id:"最简单的一个函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最简单的一个函数"}},[n._v("#")]),n._v(" 最简单的一个函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\nvoid main(){\n  // 使函数\n  findPerimeter();\n}\n\n//定义函数\nvoid findPerimeter() {\n  int length = 4;\n  int breadth = 2;\n  int perimeter = 2 * (length + breadth);\n  print(perimeter);\n}\n")])])]),a("h4",{attrs:{id:"参数函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#参数函数"}},[n._v("#")]),n._v(" 参数函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("\nvoid main(){\n  // 使函数      实参, 对应位置\n  findPerimeter(2, 4);\n}\n\n//定义函数\n                 // 位置参数1    位置参数2     形参\nvoid findPerimeter(int lenght, int breath) {\n  int perimeter = 2 * (length + breadth);\n  print(perimeter);\n}\n")])])]),a("h4",{attrs:{id:"有返回值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#有返回值"}},[n._v("#")]),n._v(" 有返回值")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main(){\n  int reactArea = getArea(2,3);\n}\n\nint getArea(int lenght, int breadth) {\n  int area = lenght * breadth;\n  return area;\n}\n")])])]),a("h4",{attrs:{id:"箭头函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数"}},[n._v("#")]),n._v(" 箭头函数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void findPerimeter(int lenght, int breath) => print(perimeter);\n\nint getArea(int lenght, int breadth) => lenght * breadth;\n\n")])])]),a("ul",[a("li",[n._v("函数体 只有一个返回语句,不用写return, 不能用 {...} 来写多条语句.")])]),n._v(" "),a("h4",{attrs:{id:"可选位置参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可选位置参数"}},[n._v("#")]),n._v(" 可选位置参数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main(){\n  printCities("广州", "深圳");\n}\n\nvoid printCities(String name1, [String name2, String name3]) {\n  print(name1);   // 广州\n  print(name2);   // 深圳\n  print(name3);   // null\n}\n')])])]),a("ul",[a("li",[n._v("[]  包括的参数, 表示该参可选 , 可以不传, 可以同包括多个")])]),n._v(" "),a("h4",{attrs:{id:"命名参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#命名参数"}},[n._v("#")]),n._v(" 命名参数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main(){\n  var result = findVolume(2, breadth: 3, height: 10);\n  print(result); // 50\n\n  var res2 = findVolume(2, height: 10, breadth: 3);\n  print(res2); // 50\n}\n\nint findVolume(int length, {int breadth, int height}) {\n  return (length + breadth) * height;\n}\n")])])]),a("ul",[a("li",[n._v("传参数, 位置不再重要了,可以不按位置传, 上例,第一个参数是位置参数,它还是要按位置来传")]),n._v(" "),a("li",[n._v("{}  里的是位置参数")]),n._v(" "),a("li",[n._v("key 是参数的名, value 是参数的值")])]),n._v(" "),a("h4",{attrs:{id:"默认参数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#默认参数"}},[n._v("#")]),n._v(" 默认参数")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main(){\n  var res1 = findVolume(2, 3, height: 5);\n  print(res1);  // 30\n  var res2 = findVolume(2, 3);\n  print(res2); // 60\n}\n\nint findVolume( int length, int breadth, { int height = 10}) {\n  return length * breadth * height;\n}\n\n\n")])])]),a("ul",[a("li",[n._v("{int name}  无论是命名参数  还是 默认参数 {int height = 10},  传参时是一样的方法")]),n._v(" "),a("li",[n._v("key: value     参数名:参数值　这样的传参都是和位置无关的")])]),n._v(" "),a("h2",{attrs:{id:"错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#错误处理"}},[n._v("#")]),n._v(" 错误处理")]),n._v(" "),a("h4",{attrs:{id:"系统错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#系统错误处理"}},[n._v("#")]),n._v(" 系统错误处理")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("void main() {\n  int result = 12~/0;\n  print(result);\n}\n")])])]),a("ul",[a("li",[n._v("~ 表示,除后结果为 int 类型")]),n._v(" "),a("li",[n._v("除数不能为 0 ,  系统会抛出一个错误, 而停止整个应用的运行")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('  try {\n    int result = 12~/0;\n    print(result);\n  } on IntegerDivisionByZeroException {\n    print("除数不能为0");\n  }\n\n\n  try {\n    int result = 12~/0;\n    print(result);\n  } catch(e) {\n    print(e);\n  }\n\n\n  try {\n    int result = 12~/0;\n    print(result);\n  } catch(e, s) {\n    print(e);\n    print(s);\n  }\n\n\n    try {\n    int result = 12~/0;\n    print(result);\n  } catch(e) {\n    print(e);\n  } finally{\n    print("finally")\n  }\n\n\n')])])]),a("ul",[a("li",[n._v("预知到错误的类型, 可以用on 具体的错误类型")]),n._v(" "),a("li",[n._v("无法预知,就用 catch(e)    e是具体的错误类型")]),n._v(" "),a("li",[n._v("s 是错误栈, 即可以用它来找到哪里出错了,错了什么")]),n._v(" "),a("li",[n._v("finally 里的代码,无论是否有错误发生,它都会执行")])]),n._v(" "),a("h4",{attrs:{id:"自定义错误处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#自定义错误处理"}},[n._v("#")]),n._v(" 自定义错误处理")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main() {\n  try {\n    depositMoney(-10);\n  } on catch(e) {\n    print(e.errorMessage)\n  }\n}\n\nclass DepositException implements Exception {\n  String errorMessage() {\n    print("u cannot enter amout less than 0");\n    return "u cannot enter amout less than 0";\n  }\n}\n\nvoid depositMoney(int amount){\n  if(amount< 0) {\n    throw new DepositException()\n  }\n')])])]),a("h2",{attrs:{id:"面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象"}},[n._v("#")]),n._v(" 面向对象")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main() {\n\n  var std1 =  Student();   // 实例化, 调用了类的 默认 构造函数\n  std1.id = 24;\n  std1.name = "Kevin";\n  std1.study();\n\n  var std2 = Student(12, \'yycu\');  // 调用有参的构造函数\n\n    var std3 = Student.myCustomConstrunctor();  //调用 自定义的构造函数\n}\n// 定义类\nclass Student {\n  int id;              // 默认值是null   实例的\n  String name;         // 默认值是null   实例的\n   \n  int age = 32;        // age 是 32     实例的\n\n  Student() {\n    // 默认的构造函数      // 可以不用写\n    print(" 默认构造函数")\n  }\n\n  Student(int id, String name) {    //有参的构造函数\n    this.id = id\n    this.name = name\n  }\n\n  Student(this.id,this.name) {    // 构造函数, 这样写更方便\n  }\n\n    \n  Student.myCustomConstrunctor() {   // myCustomConstrunctor 这个名字随你起\n     // 自定的命名构造函数\n     print("自定的命名构造函数");\n  }\n\n  void study() {\n    int id = 12;   // 作用域就在这个函数里了\n    print("${this.name} study");\n  }\n\n  void sleep() {\n    print("${this.name} sleep");\n  }\n}\n')])])]),a("ul",[a("li",[n._v("上面没有明显的声明一个 构造函数, 其它是有的,系统提供了一个无参的构造函数 Student()")]),n._v(" "),a("li",[n._v("只能定义一个构造函数, 上面只是演示, java就可以定义多个多种构造函数.")]),n._v(" "),a("li",[n._v("类同名的构造函数, 有参或无参,只能存在一个")]),n._v(" "),a("li",[n._v("命名构造函数,可以多个, 可以和")])]),n._v(" "),a("h2",{attrs:{id:"进一步了解面向对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进一步了解面向对象"}},[n._v("#")]),n._v(" 进一步了解面向对象")]),n._v(" "),a("h4",{attrs:{id:"getter-setter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter-setter"}},[n._v("#")]),n._v(" getter  setter")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main() {\n  var std = Student();\n  std.name = "yycu";\n  print(std.name);\n  \n  std.percentage = 438;  // 调用  set \n  print(std.percentage);  // 调用 get\n}\n\nclass Student {\n  String name;    // 实例属性, 默认的setter  getter\n\n  int _percent;   // 下面直接用, 没用this.xx  是把它当作本地作用域的一个变量\n                  // 也不是私有属性, 一个以 _　 开头\n\n  void set percentage(int marksSecured) {\n    _percent =  (marksSecured ~/ 500) * 100;\n  }\n\n  //  void set percentage(int marksSecured) => _percent =  (marksSecured ~/ 500) * 100;\n  \n\n  int get percentage {\n    return _percent;\n  }\n\n  // int get percentage => _percent\n}\n\n\n')])])]),a("h4",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[n._v("#")]),n._v(" 继承")]),n._v(" "),a("p",[n._v("默认所有的类 都是 继承了 Object 类")]),n._v(" "),a("p",[n._v("Object 类提供了一些默认的接口")]),n._v(" "),a("ul",[a("li",[n._v("toString()")]),n._v(" "),a("li",[n._v("hashCode")]),n._v(" "),a("li",[n._v("operator ==")])]),n._v(" "),a("p",[n._v("继承")]),n._v(" "),a("ul",[a("li",[n._v("可以代码复用")]),n._v(" "),a("li",[n._v("方法可以重写")]),n._v(" "),a("li",[n._v("不写重复代码")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v('void main() {\n\n}\n\nclass Animal {\n  String color = "brown";\n\n  void eat() {\n    print("animal eat");\n  }\n}\n\nclass Dog extends Animal {\n\n  String breed;\n\n  String color ="Black";   // 属性也会覆盖父类的属性\n\n  void eat() {       // 在子类,声明与父类同名的方法\n                      // 重写了父类的方法, 实例调用 时就是调用 自已的eat    \n    super.eat();  // 可以通过super 关键字调用 父类的方法  \n    print("Dog eat");\n\n\n  }\n\n  void bark() {\n    print("bark");\n  }\n}\n\nclass Cat extends Animal{\n  int age;\n\n\n  void meow() {\n    print("Meow!");\n  }\n}\n')])])]),a("ul",[a("li",[n._v("通过 extends 继承")])]),n._v(" "),a("p",[n._v("32")])])}),[],!1,null,null,null);t.default=r.exports}}]);