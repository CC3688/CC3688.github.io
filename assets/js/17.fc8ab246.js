(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{336:function(t,n,a){"use strict";a.r(n);var e=a(33),r=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基础"}},[t._v("#")]),t._v(" 基础")]),t._v(" "),a("h2",{attrs:{id:"create-react-app"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#create-react-app"}},[t._v("#")]),t._v(" create-react-app")]),t._v(" "),a("p",[t._v("可以全局安装, 也可以通过 npx 安装  (npx 下载 该包并使用该包, 确保每次都是最新版的)")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("> npx create-react-app my-app       //创建了一个my-app项目\n")])])]),a("p",[t._v("创建完成后, 可以在要目录下 运行")]),t._v(" "),a("p",[a("code",[t._v("npm run start")]),t._v("  启动项目  start 命令可以省略 run")]),t._v(" "),a("h2",{attrs:{id:"文件目录"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#文件目录"}},[t._v("#")]),t._v(" 文件目录")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("|-- node_modules\n|-- public\n    |-- favico.ico      浏览器标签页的小图标\n    |-- index.html      模板\n    |-- manifest.json    \n|-- src   项目的所有源代码都在这个目录下\n    |-- App.js       组件\n    |-- index.js     整个程序的入口文件       除了这两个文件其它的可以删除了\n|-- .gitignore\n|-- package.json\n|-- yarn.lock 或 package-lock.json\n|-- README.md\n")])])]),a("h2",{attrs:{id:"react-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-组件"}},[t._v("#")]),t._v(" react 组件")]),t._v(" "),a("p",[t._v("组件就是页面的各个部分")]),t._v(" "),a("p",[t._v("如: 头部组件   搜索框组件,它又可以分为输入组件和按纽组件")]),t._v(" "),a("p",[t._v("组件显示的内容, 由组件里的 render 返回的内容决定 (函数组件,则由函数返回值决定)")]),t._v(" "),a("p",[a("strong",[t._v("jsx 组件 开头, 必须以大写字母开头")])]),t._v(" "),a("h2",{attrs:{id:"react-基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-基础"}},[t._v("#")]),t._v(" react 基础")]),t._v(" "),a("p",[t._v("一个类组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("import React, { Component } from 'react'\n// import React, { Component, Fragment } from 'react'\n// render 就可以直接 用 Fragment 不用  React.Fragment\nexport default class TodoList extends Component {\n\n    constructor(props) {      //构造函数固定写法\n        super(props)\n        this.state = {       // 定义组件的状态\n            inputValue: '',\n            list: []\n        }\n        // 绑定this 如果是箭头函数就不用bind\n        this.handleInputChange = this.handleInputChange.bind(this)\n    }\n\n    render() {\n        return (\n            <React.Fragment>\n                <div>\n                    // input显示的内容同 this.state.inputValue\n                    // jsx 使用js 需要写在 {} 内\n                    <input \n                        value={this.state.inputValue}\n                        onChange={this.handleInputChange}\n                     /> \n                    //绑定事件, 它和原生事件是有区别的,react是小驼峰, 原生是小写\n                    <button>提交</button>\n                </div>\n                <ul>\n\n                </ul>\n            </React.Fragment>\n        )\n    }\n    // 使用箭头函数, 绑定了this\n    // 也可使用bind 即在 constructor 构造函数里绑定\n    handleInputChange = (e)=>{\n        e.target.value\n        this.setState({\n            inputValue: e.target.value   //只有通过setState 更新数据,视图才会更新\n        })\n    }\n    \n\n}\n")])])]),a("ul",[a("li",[t._v("return 返回的jsx 必须有且只有一个 根原素")]),t._v(" "),a("li",[t._v("<React.Fragment> 是一个虚拟的元素,不生成任何元素,类似于 vue的template")])])])}),[],!1,null,null,null);n.default=r.exports}}]);