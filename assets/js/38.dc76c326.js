(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{367:function(n,a,t){"use strict";t.r(a);var e=t(33),s=Object(e.a)({},(function(){var n=this,a=n.$createElement,t=n._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h1",{attrs:{id:"basic"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#basic"}},[n._v("#")]),n._v(" basic")]),n._v(" "),t("h2",{attrs:{id:"vscode-自动编译-ts-文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vscode-自动编译-ts-文件"}},[n._v("#")]),n._v(" vscode 自动编译 .ts 文件")]),n._v(" "),t("ol",[t("li",[n._v("在根目录下  运行"),t("code",[n._v("tsc --init")]),n._v("  生成配置文件")]),n._v(" "),t("li",[n._v("在配置文件 设置 outDir  编译后 js 文件的输出目录")]),n._v(" "),t("li",[n._v("点击vscode 菜单 > Terminal > Run Task > typescript > tsc:watch - tsconfig.json")])]),n._v(" "),t("p",[n._v("设置完成后就可以自动生成代码")]),n._v(" "),t("h2",{attrs:{id:"数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据类型"}},[n._v("#")]),n._v(" 数据类型")]),n._v(" "),t("p",[n._v("typescript 中为了使编写的代码更规范, 更有利于维护, 增加了类型校验")]),n._v(" "),t("p",[n._v("写 ts 代码必须指定类型")]),n._v(" "),t("ul",[t("li",[n._v("布尔类型 (boolean)")]),n._v(" "),t("li",[n._v("数字类型 (number)")]),n._v(" "),t("li",[n._v("字符串类型 (string)")]),n._v(" "),t("li",[n._v("数组类型 (array)")]),n._v(" "),t("li",[n._v("元组类型 (tuple)")]),n._v(" "),t("li",[n._v("枚举类型 (enum)")]),n._v(" "),t("li",[n._v("任意类型 (any)")]),n._v(" "),t("li",[n._v("null 和 undefined")]),n._v(" "),t("li",[n._v("void 类型")]),n._v(" "),t("li",[n._v("never 类型")])]),n._v(" "),t("h4",{attrs:{id:"布尔类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#布尔类型"}},[n._v("#")]),n._v(" 布尔类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let flag: boolean = true\n\n// flag =  123   //错误\n\nflag = flase   // 正确\n\n")])])]),t("h4",{attrs:{id:"数值类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数值类型"}},[n._v("#")]),n._v(" 数值类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let num: number = 123\n\nnum = 456\n\n// num = 'str'  // 错误\n\n")])])]),t("h4",{attrs:{id:"字符串类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符串类型"}},[n._v("#")]),n._v(" 字符串类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("let str: string = 'this is ts'\n\nstr = 'haha'  //正确\n\n//str = true    //错误\n\n")])])]),t("h4",{attrs:{id:"数组类型-array-ts中定义数组有两种方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组类型-array-ts中定义数组有两种方式"}},[n._v("#")]),n._v(" 数组类型(array)  ts中定义数组有两种方式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 1 第一种定义数组的方式\nlet arr: number[] = [11,22,33]\n\n// 2 第二种定义数组的方式\nlet arr2: Array<number> = [11,22,33]\n\n")])])]),t("h4",{attrs:{id:"元组类型-tuple-属于数组的一种"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#元组类型-tuple-属于数组的一种"}},[n._v("#")]),n._v(" 元组类型(tuple)  属于数组的一种")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 可以给数组中的每个元素指定类型\n\nlet arr: [number, string] = [123, 'this is ts']\n")])])]),t("h4",{attrs:{id:"枚举类型-enum"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#枚举类型-enum"}},[n._v("#")]),n._v(" 枚举类型(enum)")]),n._v(" "),t("p",[n._v("在程序中用自然语言中相应含义的单词来代表某一状态,使程序容易阅读和理解,也就是说,事先考虑到某一个变量可能取的值, 尽量用自然语言中含义清楚的单词来表示它的每一个值. 这种方法称为枚举, 用这种方法的类型称枚举类型.")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// enum Flag { success, error}\nenum Flag { success = 1, error = 2}\n\nlet s: Flag = Flag.success\n\nconsole.log(s)   // 1\n\nenum Color { blue, red, 'orange'}  // 加不加引号 一样\nlet c: Color = Color.red\nconsole.log(c)   // 1\n\n//默认一项项的值是从0开始 递增 1   如果有赋值, 则后面的值由赋值后开始 递增 1\n")])])]),t("h4",{attrs:{id:"任意类型-any"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#任意类型-any"}},[n._v("#")]),n._v(" 任意类型(any)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nlet num: any = 123\n\nnum = 'abc'\n\nnum = true\n\n// 使用\nlet oBox: any = document.getElementById('box')\n\noBox.style.color = 'red'\n\n")])])]),t("h4",{attrs:{id:"null-和-undefined-其它数据类型的子类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null-和-undefined-其它数据类型的子类型"}},[n._v("#")]),n._v(" null 和 undefined  其它数据类型的子类型")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\n// let num: number\n\n// console.log(num)     // 可以输出 undefined  报错\n\n\n\n// let num2: undefined\n// console.log(num2)   //输出 undefined  正确\n\nlet num: number | undefined\n\nnum = 123\n\nconsole.log(num)   // 123\n\n// 一个元素可能是number 类型, 可能是 null  可能是 undefined\n\nlet num: number|null|undefined\n\n")])])]),t("h4",{attrs:{id:"void类型-void表示没有任何类型-一般用于定义方法时-方法没有返回值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#void类型-void表示没有任何类型-一般用于定义方法时-方法没有返回值"}},[n._v("#")]),n._v(" void类型  void表示没有任何类型, 一般用于定义方法时, 方法没有返回值")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("function run (): void {\n\n}\n \n")])])]),t("h4",{attrs:{id:"never-类型-是其他类型-包括-null-和-undefined的子类型-代表从不会出现的值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#never-类型-是其他类型-包括-null-和-undefined的子类型-代表从不会出现的值"}},[n._v("#")]),n._v(" never 类型: 是其他类型, 包括 null 和 undefined的子类型, 代表从不会出现的值")]),n._v(" "),t("p",[n._v("意味着声明never的变量只能被never类型所赋值")]),n._v(" "),t("h2",{attrs:{id:"函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#函数"}},[n._v("#")]),n._v(" 函数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 函数声明法\nfunction run():strng {\n\n  return 'run'\n}\n\n\n// 匿名函数\nconst fun = function(): number {\n\n  return 123\n}\n\n// 传参\nfunction getInfo(name: string, age: number): string {\n\n  return `${name} --- ${age}`\n}\n\n\n// 可选参数,  参数名 带 ? 就是可选参数,  可选参数 必须在位置参数后面z\nfunctionn getInfo(name: string, age?:number):string {\n\n}\n\n// 默认参数数\nfunction getInfo(name: string, age: number =20): string {\n\n}\n\n// 三点运算符,  剩余参数, 接受新参传过来的值\n\nfunction sum(a:number, b:number: ...result: number[]): number {\n  var sum = 0\n  for( var i = 0; i < result.lenghth; i++) {\n    sum += result[i]\n  }\n  return sum\n}\n\n// ts函数重载\n// java中方法的重载, 重载指的是两个或者两个以上同名函数, 但它们的参数不一样, 这里会出现函数重载的情况\n// typescript中的重载, 通过为同一个函数提供多个函数类型定义来试下多种功能的目的\n// ts为了兼容\nfunction getInfo(name: string):string;\nfunction getInfo(age:number):number;\nfunction getInfo(str:any):any {\n  if (typeof str === 'string') {\n    return str;\n  } else {\n    return str;\n  }\n}\n\n")])])]),t("h2",{attrs:{id:"类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[n._v("#")]),n._v(" 类")]),n._v(" "),t("h4",{attrs:{id:"ts类的定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts类的定义"}},[n._v("#")]),n._v(" ts类的定义")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Person {\n  name: string;    // 属性, 前面省略了 public 关键字\n\n  constructor(name: string) {   //构造函数   实例化类的时候  触发的函数\n\n  }\n\n  getName():string {\n    return this.name;\n  }\n\n  setName(name:string):void {\n    this.name = name;\n  }\n\n  run(): void {   // 方法\n     \n  }\n}\n\n// 使用\nvar p = new Person("张三")\n\n')])])]),t("h4",{attrs:{id:"ts继承-extends-super"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ts继承-extends-super"}},[n._v("#")]),n._v(" ts继承 extends super")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Student extends Person {\n  constructor(name:string) {\n    super(name);              // 初始化父类的构造函数\n  }\n\n  run():void{\n    //子类与父类  有同样的方法,  会覆盖掉父类的方法\n  }\n}\n\n")])])]),t("h4",{attrs:{id:"修饰符"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#修饰符"}},[n._v("#")]),n._v(" 修饰符")]),n._v(" "),t("p",[n._v("ts定义属性的有三种修饰符")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("public : 公有   在类里面, 子类,  类外面都可以访问")])]),n._v(" "),t("li",[t("p",[n._v("protected : 保护类型  在类里面, 子类里面可以访问, 在类外部无法访问")])]),n._v(" "),t("li",[t("p",[n._v("private : 私有 在类里面可以访问, 子类, 类外部都无法访问")])])]),n._v(" "),t("p",[n._v("属性没写名修饰符, 则默认是public")]),n._v(" "),t("h4",{attrs:{id:"静态属性-静态方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态属性-静态方法"}},[n._v("#")]),n._v(" 静态属性  静态方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('class Person {\n  static sex="男"\n  public name: string;\n  contructor(name: string) {\n    this.name = name\n  }\n\n  run(){\n    //实例 方法\n  }\n\n  static print() {\n    //静态方法   \n    // this.name  不能调用类里面的(实例)属性\n    // Person.sex  可以调用静态属性\n  }\n}\n')])])]),t("h4",{attrs:{id:"多态-与其它语言不一样"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#多态-与其它语言不一样"}},[n._v("#")]),n._v(" 多态 (与其它语言不一样)")]),n._v(" "),t("p",[n._v("父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现,")]),n._v(" "),t("p",[n._v("多态属于继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class Animal {\n  name: string;\n  construnctor(name:string) {\n    this.name = name\n  }\n  eat() {\n    conosle.log('吃的方法')\n  }\n}\n\nclass Dog extends Animal {\n  constructor(name: string) {\n    super(name)\n  }\n  eat(){   //具体吃什么, 不知道,  由继承它的子类去实现,每一个子类的表现不一样\n    return this.name + '吃肉';\n  }\n}\n\nclass Cat extends Animal {\n  contructor(name: string){\n    super(name)\n  }\n  eat(){\n    return this.name + '吃老鼠';\n  }\n}\n")])])]),t("h4",{attrs:{id:"抽象类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#抽象类"}},[n._v("#")]),n._v(" 抽象类")]),n._v(" "),t("p",[n._v("抽象类,它是提供其它类继承的基类, 不能直接被实例化.")]),n._v(" "),t("p",[n._v("用abstract关键字定义抽象类和抽象方法, 抽象类中的抽象方法不包含具体的实现")]),n._v(" "),t("p",[n._v("抽象方法只能放在抽象类里面")]),n._v(" "),t("p",[n._v("抽象类和抽象方法用来定义标准, 继续它的子类必须实现抽象方法")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("abstract class Animal {\n  abstract eat():any;\n}\n// 这个抽象能不能实例化\n\nclass Dog extends Animal {\n  construnctor(){\n\n  }\n  eat() {\n    // 实现抽象类的方法\n  }\n}\n\n")])])]),t("h4",{attrs:{id:"接口"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[n._v("#")]),n._v(" 接口")]),n._v(" "),t("p",[n._v("接口的作用: 在面向对象的编程中, 接口是一种规范定义, 它定义了行为和动作的规范,在程序设\n计里,接口起到一种限制规范的作用. 接口只定义规范,不关心具体的实现.ts中的接口类似java\n同时还增加了更灵活的接口类型,包括属性,函数,可索引和类等.")]),n._v(" "),t("p",[t("strong",[n._v("属性接口")]),n._v(" 对json的约束")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\ninterface FullName {\n  firstName: string;\n  secondName?: string;  // ? 表示可选\n}\n\nfunction printName(name: FullName) {\n\n}\n\nprintName({\n  firstName: 'chen',\n  secondName: 'Kevin',    //这样写,必须和 interface 定义的一样\n})\n\nvar obj = {\n  age: 20,\n  firstName: 'chen',\n  secondName: '三'\n}\nprintName(obj)     //传入的参数必须包含 firstName 和 secondName\n")])])]),t("p",[t("strong",[n._v("函数类型接口")]),n._v(" 对方法传入的参数 以及返回值进行约束")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("interface encrypt {\n  (key:string, value: string):string;\n}\n\nvar md5:encrypt = function(key:string, value:string): string {\n\n}\n\n//另一种定义函数\nvar md5: (key:string, value:string) => string = function(key:string, value:string): string {\n\n}\n")])])]),t("p",[t("strong",[n._v("可索引接口,数组,对象的约束  (不常用)")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 定义数组的方式\nvar arr: number[] = [2342, 235]\nvar arr1: Array<string> = ['aaa', '222']\n\n\n//对数组的约束\ninterface UserArr {\n  [index:number]:string    //索引是number  值是 string\n}\n\nvar arr: UserArr = ['aaa', 'bbb']\n\n\n// 可索引接口, 对对象的约束\n\ninterface UserObj {\n  [index:string]:string\n}\n\nvar arr:UserObj = {name: '张三'}\n\n\n// 类类型接口: 对类的约束 和 抽象类的点相似\n\ninterface Animal {\n  name: string;\n  eat(str:string): void;\n}\n\nclass Dog implements Animal {\n  name: string;\n  constructor(name: string) {\n    this.name = name\n  }\n  eat() {\n    console.log('xxxx');\n  }\n}\n")])])]),t("p",[t("strong",[n._v("接口的扩展")])]),n._v(" "),t("p",[n._v("接口的继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("interface Animal {\n  eat(): void;\n}\n\ninterface Person extends Animal {\n\n  work(): void\n}\n\nclass Programmer {\n  public name: string;\n  constructor(name: string){\n    this.name = name\n  }\n\n  coding(code: string) {\n    console.log(this.name + code)\n  }\n}\n\n// 父接口,也要实现\nclass Web extends Programer implements Person {\n  constructor(name: string){\n    super(this.name)\n    this.name = name\n  }\n\n  eat(){\n    // pass\n  }\n\n  work() {\n    // pass\n  }\n}\n\n\n\n")])])]),t("h4",{attrs:{id:"泛型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[n._v("#")]),n._v(" 泛型")]),n._v(" "),t("p",[n._v("软件工程中, 我们不仅要创建一致定义良好的api, 同时也要考虑可重用性, 组件不仅能够支持当前的数据类型, 同时也能支持未来\n的数据类型, 这在创建大型系统时为你提供了十分灵活的功能")]),n._v(" "),t("p",[n._v("在c# java中, 可以使用泛型来创建可重用的组件, 一个组件可以支持多种类型的数据, 这样用户就可以自己的数据类型来使用组件")]),n._v(" "),t("p",[n._v("通俗理解: 泛型是解决 类 接口 方法  的复用性, 以及对不特定数据类型的支持")]),n._v(" "),t("p",[n._v("可以帮助我们避免重复的代码以及对不特定数据类型的支持(类型校验)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('// 只能返回string 类型的数据\nfunction getData(value: string): string {\n  return value\n}\n\n// 同时返回 string  和 number\nfunction getData1(value: string): string {\n  return value\n}\n\nfunction getData2(value: number): number {\n  return value\n}\n\n//上面这样写,代码就 冗余了\n\nfunction getData3(value: any): any {\n  return value\n}\n\n// 这样,传入 123 ,却可以返回 "哈哈"  ,用any 相当于放弃了类型检查\n\n// 传入什么, 返回什么,  传number 返number     传string 返string\n\n\n')])])]),t("p",[n._v("泛型: 可以支持不特定的数据类型,  要求: 传入的参数和返回的参数一到处")]),n._v(" "),t("p",[n._v("T 表示泛型, 具体什么类型是调用这个方法的时候决定的 (你可以用 A 或 B 来表示)")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//             声明        使用  使用\nfunction getData<T> (value: T): T {\n  return value\n}\n\n// 可以同时声明多个泛型\n\n//使用\n\ngetData<number>(123)      // 对\ngetData<strign>('abc')    //对\ngetData<number>('2111')   //错误写法\n\n\n")])])]),t("p",[t("strong",[n._v("泛型类")])]),n._v(" "),t("p",[n._v("比如有个最小堆算法, 需要同时支持返回数字和字符串 a-z两种类型, 通过类的泛型来实现")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("\nclass MinClass {\n  public list: number[] = [];\n\n  add(num: number) {\n    this.list.push(num)\n  }\n\n  min() {\n    var minNum = this.list[0]\n    for(var i=0; i< this.list.length; i++) {\n      if(minNum > this.list[i]) {\n        minNum = this.list[i]\n      }\n    }\n    retrun minNum\n\n  }\n}\n\n\nvar m = new MinClass()\nm.add(2)\nm.add(3)\nm.add(21)\nm.add(1)\nalert(m.min())\n\n\n//类的泛型\nclass MinClass<T> {\n  public list: T[] = []\n\n  add(value: T): void {\n    this.list.push(value)\n  }\n\n  min(): T {\n    var minNum = this.list[0]\n    for(var i=0; i< this.list.length; i++) {\n      if(minNum > this.list[i]) {\n        minNum = this.list[i]\n      }\n    }\n    retrun minNum\n\n  }\n\n}\n\nvar m1 = new MinClass<number>(); //实例化类, 并且指定了类的T代表的类型是numberm\n\n")])])]),t("p",[t("strong",[n._v("泛型接口")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//普通接口\ninterface ConfigFn {\n  (value1: string, value2: string): string;\n}\n\nvar setData: ConfigFn = function(value1: string, value2: string):strign {\n  return value1 + value2\n}\n\n//泛型接口\ninterface ConfigFn {\n  <T>(value1: T, value2: T): T;\n}\n\nvar setData: ConfigFn = function<T>(value1: T, value2: T):T {\n  return value1 + value2\n}\n\nsetData<string>('张三', '李四')  //正确写法\nsetData<string>(1,2)   //错误写法\n")])])]),t("p",[n._v("再一个例子")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("interface ConfigFn<T> {\n  (value: T): T;\n}\n\nfunction getData<T>(value:T):T {\n  return value\n}\n\nvar myGetData:ConfigFn<string> =getData\n\nmyGetData('20')  //对\nmyGetData(20)  //错\n\n")])])]),t("p",[n._v("例子")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class User {\n  username: string | undefined;\n  password: string | underfined;\n}\n\nclass MysqlDb {\n  add(user: User): boolean {\n    return true;\n  }\n}\n\n\nvar u = new User();\nu.username = '张三';\nu.password = '123456';\n\nvar DB = new MySqlDb();\nDb.add(u)\n////////////////////\n\nclass ArticleCate {\n  title: string | undefined;\n  desc: string | undefined;\n  status: number | undefined;\n}\nclass MysqlDb {\n  add(articleCate: ArticleCate): boolean {\n    return true;\n  }\n}\n\nvar a = new ArticleCate()\na.title = '国内'\na.desc = '国内新闻'\na.status = 1\n\nvar Db = new MySqlDb()\nDb.add(a)\n\n// 以上,造成了代码冗余 MysqlDb\nclass MysquDb<T> {\n  add(info: T): boolean {\n    console.log(info)\n    return true\n  }\n}\n\nclass User {\n  username: string | undefined;\n  password: string | underfined;\n}\n\nvar u = new User();\nu.username = 'yycu'\nu.password = '123456'\n\nvar Db = new MysqlDb<User>()\n\nDb.add(u)\n\n")])])]),t("h4",{attrs:{id:"模块"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块"}},[n._v("#")]),n._v(" 模块")]),n._v(" "),t("p",[n._v("ts1.5里术语已经发生了变化, 内部模块  现在称做 命名空间,   外部模块  现简称 模块")]),n._v(" "),t("p",[n._v("模块在其自身的作用域里执行, 而不是全局作用域里")]),n._v(" "),t("p",[n._v("这意味着定义一个模块里的变量, 函数, 类等等, 在模块外部是不可见的, 除非你明确地使用export")]),n._v(" "),t("p",[n._v("形式之一导出它们")]),n._v(" "),t("p",[n._v("而如果你想使用其它模块导出的变量,函数,类,接口等的时候, 你必须导入它们, 可以使用 import形式之一")]),n._v(" "),t("p",[n._v("我们可以把一些公共的功能单独抽离成一个文件作为一个模块.")]),n._v(" "),t("p",[n._v("模块里面的变理, 函数, 类等默认是私有的, 如果我们要在外部访问模块里面的数据(变量, 函数, 类)")]),n._v(" "),t("p",[n._v("我们需要通过export暴露模块里面的数据(变量, 函数, 类...)")]),n._v(" "),t("p",[n._v("暴露后我们通过 import 引入模块, 就可以使用被引入模块里面数据(变量,函数, 类...)")]),n._v(" "),t("h4",{attrs:{id:"命名空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#命名空间"}},[n._v("#")]),n._v(" 命名空间")]),n._v(" "),t("p",[n._v("命名空间: 内部模块, 主要用于组织代码, 避免命名冲突")]),n._v(" "),t("p",[n._v("模块:  ts 外部模块的简称, 侧重代码的复用, 一个模块里可能会有多个命名空间")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 在代码的最上部\nnamespace A {\n\n export class Dog {\n\n }\n}\n\n\nnamespace B {\n  export class Dog {\n   \n }\n\n}\n\nA 空间  B 空间   里可以有同名的变量,函数.....\n命名空间里面的东西默认是私有的, 需要export出去外部才能用,\n通过 . 运算符 使用\n\n\nvar d = new A.dog()\nvar e = new B.dog()\n\n")])])]),t("p",[n._v("把命名空间  像模块导出")]),n._v(" "),t("p",[n._v("在一个ts.文件")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("export namespace A {\n\n export class Dog {\n\n }\n}\n\n\nexport namespace B {\n  export class Dog {\n   \n }\n\n}\n\n")])])]),t("p",[n._v("在其它模块引入")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("import {A} from '../' // 上面文件的地址\n\nvar d = new A.Dog()\n")])])]),t("h4",{attrs:{id:"装饰器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装饰器"}},[n._v("#")]),n._v(" 装饰器")]),n._v(" "),t("p",[n._v("是一种特殊类型声明, 它能够被附加到类声明,方法,属性或参数上, 可以修改类的行为.")]),n._v(" "),t("p",[n._v("通俗的讲装饰器就是一个方法, 可以注入到类,方法,属性参数上来扩展类,属性,方法,参数的功能")]),n._v(" "),t("p",[n._v("常见的装饰器有: 类装饰器,属性装饰器, 方法装饰器,参数装饰器")]),n._v(" "),t("p",[n._v("装饰器的写法: 普通装饰器(无法传参), 装饰器工厂(可以传参)")]),n._v(" "),t("p",[n._v("装饰器是过去几年js最大的成就之一, 已经是es7的标准特性之一")]),n._v(" "),t("p",[t("strong",[n._v("类装饰器")])]),n._v(" "),t("p",[n._v("类装饰器在类声明之前被声明 (紧靠着类声明), 类装饰器应用于类构造函数,可以用来监视\n修改或替换类定义.")]),n._v(" "),t("p",[n._v("类装饰器表达式会在运行时当作函数被调用, 类的构造函数作为其唯一的参数")]),n._v(" "),t("p",[n._v("如果类装饰器返回一个值,它会使用提供的构造函数来替换类的声明")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//定义一个装饰器\nfunction logClass(target: any) {\n  console.log(target)\n  //target 就是当前类\n\n  // 给类扩展属性\n  target.prototype.apiUrl = 'xxx'\n}\n\n\n//使用\n@logClass\nclass HttpClient {\n  constructor(){\n\n  }\n  getData(){\n\n  }\n}\n\n\nvar http = new HttpClient()\nconsole.log(http.apiUrl)\n\n\n//装饰器工厂,可传参\nfunction logClass(params: string){\n  // params 是装饰器传入的参数\n\n\n  // 这个就是上面定义的 装饰器\n  return function(target){\n    target.prototype.apiUrl = params\n  }\n}\n\n\n//如果类装饰器返回一个值,它会使用提供的构造函数来替换类的声明\nfunction logClass(target:any) {\n  return class extends target {\n    apiUrl:any = '我是修改后的数据'\n    getData() {\n      console.lgo(this.apiUrl)\n    }\n  }\n}\n\n\n@logClass\nclass HttpClient {\n  public apiUrl: string | undefined;\n  constructor() {\n    this.apiUrl = '我是构造函数里面的apiurl'\n  }\n\n  getData() {\n    console.log(this.apiurl)\n  }\n}\nvar http = new HttpClient()\nhttp.getData()  //我是修改后的数据\n\n")])])]),t("p",[t("strong",[n._v("属性装饰器")]),n._v("\n属性装饰器表达式会在运行时当作函数被调用, 传入下列2个参数\n1, 对于静态成员来说是类的构造函数,对于实例成员是类的原型对象\n2, 成员的名字")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//类装饰器\nfunction logClass(target: any) {\n  console.log(target)\n  //target 就是当前类\n\n  // 给类扩展属性\n  target.prototype.apiUrl = 'xxx'\n}\n\n//属性装饰器\nfunction logProperty(params: any) {\n  return function(target:any, attr: any){\n    // target   类的原型对象, 相当于类装饰器的target.prototype\n    // attr    属性的名称\n    target[attr] = params\n  }\n}\n\n\n//使用\n@logClass\nclass HttpClient {\n  @logProperty('aaa')\n  public url: any|undefined;\n  constructor(){\n\n  }\n  getData(){\n\n  }\n}\n\n")])])]),t("p",[t("strong",[n._v("方法装饰器")])]),n._v(" "),t("p",[n._v("它会被应用到方法的 属性描述上,可以用来监视,修改或者替换方法定义")]),n._v(" "),t("p",[n._v("方法装饰会在运行时传入下列3个参数\n1 对于静态成员来说是类的构造函数,对于实例成员是类的原型\n2 成员的名字\n3 成员的属性描述")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//装饰器\nfunction get(params:any) {\n  return function(target:any, methodName:any, desc:any){\n    //target: 对于静态成员来说是类的构造函数,对于实例成员是类的原型\n    //methodName: 方法名字,成员名字\n    //desc: 方法的描述,可以修改这个方法\n    targt.apiUrl = 'xxx'\n    target.run = function(){\n\n    }\n\n  }\n}\n\n//装饰器  修改方法\nfunction get(params:any) {\n  return function(target:any, methodName:any, desc:any){\n    //target: 对于静态成员来说是类的构造函数,对于实例成员是类的原型\n    //methodName: 方法名字,成员名字\n    //desc: 方法的描述,可以修改这个方法\n    // 修改装饰器的方法   把装饰器方法里面传入的所有参数改为string类型\n    //1 保存当前的方法\n    var oMenthod = desc.value\n\n    desc.value = function(...args: any[]){\n      args = args.map((value)=>{\n        return String(value)\n      })\n      console.log(args)\n\n      oMethod.apply(this, args)\n    }\n\n  }\n}\n\n//使用\nclass HttpClient {\n  public url: any|undefined;\n  constructor(){\n\n  }\n\n  @get('aaa')\n  getData(){\n\n  }\n}\n\n\n")])])]),t("p",[t("strong",[n._v("方法参数装饰器")]),n._v("\n参数装饰器表达式会在运行时当作函数被调用, 可以使用参数装饰器为类的原型增加一些元素数据,\n传入下列3个参数\n1 对于静态成员来说是构造函数, 对于实例成员是类的原型对象\n2 参数名字\n3 参数在函数列表中的索引")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//参数装饰器\nfunction logParams(params: any) {\n  return function(target: any, paramsName: any, paramsIndex: any){\n    //target: 对于静态成员来说是类的构造函数,对于实例成员是类的原型\n    //paramsName:  方法的名字\n    //paramsIndex: 参数在函数  参数列表中的索引 \n  }\n}\n\n\n//使用\nclass HttpClient {\n  public url: any|undefined;\n  constructor(){\n\n  }\n\n \n  getData(@logParams('uuid') uuid: any){\n\n  }\n}\n\n")])])]),t("p",[t("strong",[n._v("装饰器执行顺序")])]),n._v(" "),t("p",[n._v("属性装饰器 >>  方法装饰器  >>  方法参数装饰器  >>  类装饰器")]),n._v(" "),t("p",[n._v("如果一个种装饰器里有多个同样的装饰器,它会先执行后面的")])])}),[],!1,null,null,null);a.default=s.exports}}]);